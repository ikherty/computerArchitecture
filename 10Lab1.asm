; Используя только операцию OUTCH, -Макрокоманда вывода символа на экран
; вывести содержимое регистра AX 
; в виде беззнакового 16-ричного числа («буквенные» цифры — от A до F).

format ELF64 executable 3
entry start
;include 'win64a.inc'

segment readable executable
start:

;////////////////////////////// Тут происходит вся магия
	mov rbx, table; указываю где неходится таблица для xlatb
	mov rdi, temp+3; указываю куда записывать 16-ные значения
	std; запись будет происходить в обратную сторону (от больших адресов к меньшим)
	mov rax, [number]; запихиваю число в RAX
	and rax, 0xffff; оставляю только последние 4 байта
	mov rbp, rax; теперь это число будет храниться в RBP
 .loop1:
	mov rax, rbp; Считываю число
	shr rbp, 4; сдвигаю его вправо на 4 бита
	and rax, 0xf; очищаю все биты кроме первых 4-х (значение в AL является индексом в таблице по адресу в RBX. см. строку 13)
	xlatb; Достаю байт из таблицы
	stosb; сохраняю его в буффер
	test rbp,rbp; Если я обработал не все, то начать заново
	jne .loop1; начать цикл заново
;//////////////////////////////
.exit:
	;PRINT
	mov edx, 5 ; string lenth
	mov rsi, temp
	mov edi, 1
	mov eax, 1
	syscall ; WriteConsole

	xor edi, edi ; Exit
	mov eax, 60
	syscall

segment readable writable
	number dq 0xdeadbeef; то самое число которе мы хотим представить в 16-м виде
	temp db '0','0','0','0',10; Инициализирую строку нулями, чтобы числа < 0x1000 отображались корректно
	table db '0123456789ABCDEF'; таблица символов, которую будет использовать XLATB
